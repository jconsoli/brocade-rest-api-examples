#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Copyright 2024, 2025 Consoli Solutions, LLC.  All rights reserved.

**License**

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
the License. You may also obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
language governing permissions and limitations under the License.

The license is free for single customer use (internal applications). Use of this module in the production,
redistribution, or service delivery for commerce requires an additional license. Contact jack@consoli-solutions.com for
details.

**Description**

Creates switch configuration workbooks for each chassis from a project for use with switch_config.py

**Version Control**

+-----------+---------------+---------------------------------------------------------------------------------------+
| Version   | Last Edit     | Description                                                                           |
+===========+===============+=======================================================================================+
| 1.0.0     | 06 Dec 2024   | Initial Launch                                                                        |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 1.0.1     | 04 Jan 2025   | Added core-4 blade sheets, fixed port switches, and column for CLI                    |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 1.0.2     | 01 Mar 2025   | Error message enhancements.                                                           |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 1.0.3     | 25 Aug 2025   | Removed unused code.                                                                  |
+-----------+---------------+---------------------------------------------------------------------------------------+
"""
__author__ = 'Jack Consoli'
__copyright__ = 'Copyright 2024, 2025 Consoli Solutions, LLC'
__date__ = '25 Aug 2025'
__license__ = 'Apache License, Version 2.0'
__email__ = 'jack_consoli@yahoo.com'
__maintainer__ = 'Jack Consoli'
__status__ = 'Released'
__version__ = '1.0.3'


import os
import collections
import openpyxl as xl_wb
from openpyxl.worksheet.datavalidation import DataValidation
import openpyxl.utils.cell as xl
import brcdapi.log as brcdapi_log
import brcdapi.excel_util as excel_util
import brcdapi.excel_fonts as excel_fonts
import brcdapi.util as brcdapi_util
import brcdapi.gen_util as gen_util
import brcdapi.file as brcdapi_file
import brcddb.brcddb_project as brcddb_project
import brcddb.brcddb_common as brcddb_common
import brcddb.brcddb_fabric as brcddb_fabric
import brcddb.brcddb_switch as brcddb_switch
import brcddb.brcddb_port as brcddb_port
import brcddb.util.iocp as brcddb_iocp
import brcddb.brcddb_chassis as brcddb_chassis
import brcddb.util.util as brcddb_util
import brcddb.classes.util as class_util
import brcddb.report.utils as report_utils

_DOC_STRING = False  # Should always be False. Prohibits any code execution. Only useful for building documentation

_config_d = dict(x64='templates/X6-4_Switch_Configuration.xlsx',
                 x68='templates/X6-8_Switch_Configuration.xlsx',
                 x74='templates/X7-4_Switch_Configuration.xlsx',
                 x78='templates/X7-8_Switch_Configuration.xlsx',
                 fixed='templates/Fixed_Port_Switch_Configuration.xlsx')

_valid_switch_type_l = [str(k) for k in _config_d.keys()]
_input_d = dict(
    i=dict(h='Required. Name of input file generated by capture.py, combine.py, or multi_capture.py. Extension '
             '".json" is automatically added if no extension present.'),
    o=dict(r=False, d='',
           h='Optional. Name of folder to place output files in. Output files use the chassis name. This is just the '
             'name of the folder to put them in. If the folder does not exist, it will be created. By default, files '
             'are place in the same folder the script was run from.'),
)
_input_d.update(gen_util.parseargs_log_d.copy())

# Common worksheet cell formatting
_hdr1_font = excel_fonts.font_type('hdr_1')
_hdr2_font = excel_fonts.font_type('hdr_2')
_white_bold_font = excel_fonts.font_type('white_bold')
_bold_font = excel_fonts.font_type('bold')
_std_font = excel_fonts.font_type('std')
_link_font = excel_fonts.font_type('link')
_fill_slot = excel_fonts.fill_type('config_slot')
_align_wrap = excel_fonts.align_type('wrap')
_align_wrap_c = excel_fonts.align_type('wrap_center')
_border_thin = excel_fonts.border_type('thin')

_skip_sheets = ('CLI_Bind',)
_copy_sheets_d = collections.OrderedDict()
_copy_sheets_d['VC'] = dict(font=_std_font, hidden=True)
_copy_sheets_d['lists'] = dict(font=_std_font, hidden=True)
_copy_sheets_d['Instructions'] = dict(width_l=(88,), font=_std_font, align=_align_wrap)

_chassis_sheet_d = dict(
    width=(25, 20, 80),
    hdr=(
        dict(buf='Area', font=_bold_font, align=_align_wrap, border=_border_thin),
        dict(buf='Parameter', font=_bold_font, align=_align_wrap_c, border=_border_thin),
        dict(buf='Comments', font=_bold_font, align=_align_wrap, border=_border_thin),
    )
)

_apt_policy_d = {'exchange-based': 'EBR', 'device-based': 'DBR'}  # Used in _switch_config()


class Found(Exception):
    pass


# Functions used in _slot_sheet_d
def _port_num(port_obj, row):
    """Returns the port number

    :param port_obj: Port object
    :type port_obj: brcddb.classes.port.PortObj
    :param row: Current row number
    :type row: int
    :return: Port number
    :rtype: int
    """
    return port_obj.r_port()


def _port_did(port_obj, row):
    """Returns the Domain ID for the port in Hex. See _port_num() for parameter definitions"""
    addr = port_obj.r_addr()
    if isinstance(addr, str):
        link_addr = addr[2:4].upper()
        return link_addr[1:] if link_addr[0] == '0' else link_addr
    return None


def _port_addr(port_obj, row):
    """Returns the port address (middle byte of FC address) in Hex. See _port_num() for parameter definitions"""
    addr = port_obj.r_addr()
    return None if addr is None else addr[4:6].upper()


def _port_index(port_obj, row):
    """Returns the port index. See _port_num() for parameter definitions"""
    return port_obj.r_index()


def _port_link_addr_l(port_obj, row):
    """Returns the link address formula for left column or ports. See _port_num() for parameter definitions"""
    buf = '=IF(HEX2DEC(D$row)>15,IF(HEX2DEC(C$row) > 15,CONCATENATE(C$row,D$row),CONCATENATE("0",C$row,D$row)),'\
          'IF(HEX2DEC(C$row) > 15,CONCATENATE(C$row,"0",D$row),CONCATENATE("0",C$row,"0",D$row)))'
    return buf.replace('$row', str(row))


def _port_link_addr_r(port_obj, row):
    """Returns the link address formula for left column or ports. See _port_num() for parameter definitions"""
    buf = '=IF(HEX2DEC(P$row)>15,IF(HEX2DEC(O$row) > 15,CONCATENATE(O$row,P$row),CONCATENATE("0",O$row,P$row)),'\
          'IF(HEX2DEC(O$row) > 15,CONCATENATE(O$row,"0",P$row),CONCATENATE("0",O$row,"0",P$row)))'
    return buf.replace('$row', str(row))


def _fid(port_obj, row):
    """Returns the FID number. See _port_num() for parameter definitions"""
    switch_obj = port_obj.r_switch_obj()
    return 0 if switch_obj is None else switch_obj.r_fid()


def _cli(port_obj, row):
    """Returns CLI for port configurations. See _port_num() for parameter definitions
    
    ToDo - -cli is a work in progress"""
    return None


def _attached_dev(port_obj, row):
    """Returns the attached device information. See _port_num() for parameter definitions"""
    return brcddb_port.port_best_desc(port_obj)


def _port_name(port_obj, row):
    """Returns the port name. See _port_num() for parameter definitions"""
    port_name = port_obj.r_port_name()
    return None if len(port_name) == 0 else port_name


def _low_qos_l(port_obj, row):
    """Returns the formula for QoS_L for left columns. See _port_num() for parameter definitions"""
    return '=LOOKUP(HEX2DEC(MID(F' + str(row) + ',4,1)),VC!A1:C16)'


def _med_qos_l(port_obj, row):
    """Returns the formula for QoS_M for left columns. See _port_num() for parameter definitions"""
    return '=LOOKUP(HEX2DEC(MID(F' + str(row) + ',4,1)),VC!A1:B16)'


def _high_qos_l(port_obj, row):
    """Returns the formula for QoS_H for left columns. See _port_num() for parameter definitions"""
    return '=LOOKUP(HEX2DEC(MID(F' + str(row) + ',4,1)),VC!A1:D16)'


def _low_qos_r(port_obj, row):
    """Returns the formula for QoS_L for right columns. See _port_num() for parameter definitions"""
    return '=LOOKUP(HEX2DEC(MID(R' + str(row) + ',4,1)),VC!A1:C16)'


def _med_qos_r(port_obj, row):
    """Returns the formula for QoS_M for right columns. See _port_num() for parameter definitions"""
    return '=LOOKUP(HEX2DEC(MID(R' + str(row) + ',4,1)),VC!A1:B16)'


def _high_qos_r(port_obj, row):
    """Returns the formula for QoS_H for right columns. See _port_num() for parameter definitions"""
    return '=LOOKUP(HEX2DEC(MID(R' + str(row) + ',4,1)),VC!A1:D16)'


_slot_sheet_d = dict(
    pc_48=dict(
        hdr=(
            dict(col=3),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='DID (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Port Addr (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=7, buf='Link Addr', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Attached Device', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Low Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Med Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='High Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=2),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='DID (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Port Addr (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=7, buf='Link Addr', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Attached Device', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Low Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Med Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='High Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin)
        ),
        port=dict(),
    ),
    pc_64=dict(
        hdr=(
            dict(col=3),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='DID (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Port Addr (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=7, buf='Link Addr', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Attached Device', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Low Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Med Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='High Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=2),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='DID (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Port Addr (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=7, buf='Link Addr', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Attached Device', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Low Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Med Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='High Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin)
        ),
        port=dict()
    ),
    core_4=dict(
        hdr=(
            dict(col=3),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='ICL Description', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=2),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='ICL Description', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
        ),
        port=dict()
    ),
    core_8=dict(
        hdr=(
            dict(col=3),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='ICL Description', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=2),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='ICL Description', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
        ),
        port=dict()
    ),
    fixed_64=dict(
        hdr=(
            dict(col=3),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='DID (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Port Addr (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=7, buf='Link Addr', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Attached Device', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Low Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Med Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='High Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
        ),
        port=dict()
    ),
    fixed_128=dict(
        hdr=(
            dict(col=3),
            dict(col=5, buf='Port', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='DID (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Port Addr (Hex)', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=6, buf='Index', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=7, buf='Link Addr', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='FID', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=4, buf='CLI', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Attached Device', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=27, buf='Port Name', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Low Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='Med Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
            dict(col=5, buf='High Qos VC', font=_std_font, align=_align_wrap_c, border=_border_thin),
        ),
        port=dict()
    ),
)

# Fill in the _slot_sheet_d for 48 port cards
_pc_48_asic_map_d = {
    0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 1, 9: 1, 10:  1, 11: 1, 12: 1, 13: 1, 14: 1, 15: 1,
    16: 1, 17: 1, 18: 1, 19: 1, 20: 1, 21: 1, 22: 1, 23: 1, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0,
    32: 0, 33: 0, 34: 0, 35: 0, 36: 0, 37: 0, 38: 0, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1,
}
_row = 27
for port in range(0, 24): 
    _col_l_l = [
        dict(row=_row, col=2, buf=_port_num, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=3, buf=_port_did, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=4, buf=_port_addr, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=5, buf=_port_index, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=6, buf=_port_link_addr_l, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=7, buf=_fid, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=8, buf=_cli, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=9, buf=_attached_dev, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=10, buf=_port_name, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=11, buf=_low_qos_l, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=12, buf=_med_qos_l, asic=_pc_48_asic_map_d[port]),
        dict(row=_row, col=13, buf=_high_qos_l, asic=_pc_48_asic_map_d[port]),
    ]
    _slot_sheet_d['pc_48']['port'].update({port: _col_l_l.copy()})
    _row -= 1
_row = 27
for _port in range(24, 48):
    _col_r_l = [
        dict(row=_row, col=15, buf=_port_num, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=16, buf=_port_did, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=17, buf=_port_addr, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=18, buf=_port_index, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=19, buf=_port_link_addr_l, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=20, buf=_fid, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=21, buf=_cli, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=22, buf=_attached_dev, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=23, buf=_port_name, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=24, buf=_low_qos_l, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=25, buf=_med_qos_l, asic=_pc_48_asic_map_d[_port]),
        dict(row=_row, col=26, buf=_high_qos_l, asic=_pc_48_asic_map_d[_port]),
    ]
    _slot_sheet_d['pc_48']['port'].update({_port: _col_r_l.copy()})
    _row -= 1

# Fill in the _slot_sheet_d for 64 port cards
_pc_64_asic_map_d = {
    0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0,
    16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0,
    32: 1, 33: 1, 34: 1, 35: 1, 36: 1, 37: 1, 38: 1, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1,
    48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1,
}
_row = 35
for _port in range(0, 32):
    _col_l_l = [
        dict(row=_row, col=2, buf=_port_num, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=3, buf=_port_did, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=4, buf=_port_addr, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=5, buf=_port_index, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=6, buf=_port_link_addr_l, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=7, buf=_fid, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=8, buf=_cli, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=9, buf=_attached_dev, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=10, buf=_port_name, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=11, buf=_low_qos_l, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=12, buf=_med_qos_l, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=13, buf=_high_qos_l, asic=_pc_64_asic_map_d[_port]),
    ]
    _slot_sheet_d['pc_64']['port'].update({_port: _col_l_l.copy()})
    _row -= 1
_row = 35
for _port in range(32, 64):
    _col_r_l = [
        dict(row=_row, col=15, buf=_port_num, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=16, buf=_port_did, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=17, buf=_port_addr, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=18, buf=_port_index, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=19, buf=_port_link_addr_l, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=20, buf=_fid, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=21, buf=_cli, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=22, buf=_attached_dev, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=23, buf=_port_name, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=24, buf=_low_qos_l, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=25, buf=_med_qos_l, asic=_pc_64_asic_map_d[_port]),
        dict(row=_row, col=26, buf=_high_qos_l, asic=_pc_64_asic_map_d[_port]),
    ]
    _slot_sheet_d['pc_64']['port'].update({_port: _col_r_l.copy()})
    _row -= 1
    
# Fill in the _slot_sheet_d for 4 slot core blade.
_core_4_asic_map_d = {
    0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0,
    16: 1, 17: 1, 18: 1, 19: 1, 20: 1, 21: 1, 22: 1, 23: 1, 24: 1, 25: 1, 26: 1, 27: 1, 28: 1, 29: 1, 30: 1, 31: 1,
}
_row = 19
for _port in range(0, 16):
    _col_l_l = [
        dict(row=_row, col=2, buf=_port_num, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=3, buf=_port_index, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=4, buf=_fid, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=5, buf=_cli, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=6, buf=_attached_dev, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=7, buf=_port_name, asic=_core_4_asic_map_d[_port]),
    ]
    _slot_sheet_d['core_4']['port'].update({_port: _col_l_l.copy()})
    _row -= 1
_row = 19
for _port in range(16, 32):
    _col_l_l = [
        dict(row=_row, col=9, buf=_port_num, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=10, buf=_port_index, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=11, buf=_fid, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=12, buf=_cli, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=13, buf=_attached_dev, asic=_core_4_asic_map_d[_port]),
        dict(row=_row, col=14, buf=_port_name, asic=_core_4_asic_map_d[_port]),
    ]
    _slot_sheet_d['core_4']['port'].update({_port: _col_l_l.copy()})
    _row -= 1

# Fill in the _slot_sheet_d for 8 slot core blade.
_core_8_asic_map_d = {
    0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0,
    16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0,
    32: 1, 33: 1, 34: 1, 35: 1, 36: 1, 37: 1, 38: 1, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1,
    48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1,
}
_row = 35
for _port in range(0, 32):
    _col_l_l = [
        dict(row=_row, col=2, buf=_port_num, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=3, buf=_port_index, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=4, buf=_fid, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=5, buf=_cli, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=6, buf=_attached_dev, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=7, buf=_port_name, asic=_core_8_asic_map_d[_port]),
    ]
    _slot_sheet_d['core_8']['port'].update({_port: _col_l_l.copy()})
    _row -= 1
_row = 35
for _port in range(32, 64):
    _col_l_l = [
        dict(row=_row, col=9, buf=_port_num, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=10, buf=_port_index, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=11, buf=_fid, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=12, buf=_cli, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=13, buf=_attached_dev, asic=_core_8_asic_map_d[_port]),
        dict(row=_row, col=14, buf=_port_name, asic=_core_8_asic_map_d[_port]),
    ]
    _slot_sheet_d['core_8']['port'].update({_port: _col_l_l.copy()})
    _row -= 1

# Fill in the _slot_sheet_d for 64 port fixed port switches. These are single ASIC switches, so no point in creating an
# ASIC map
_row = 67
for _port in range(0, 64):
    _col_l_l = [
        dict(row=_row, col=2, buf=_port_num, asic=0),
        dict(row=_row, col=3, buf=_port_did, asic=0),
        dict(row=_row, col=4, buf=_port_addr, asic=0),
        dict(row=_row, col=5, buf=_port_index, asic=0),
        dict(row=_row, col=6, buf=_port_link_addr_l, asic=0),
        dict(row=_row, col=7, buf=_fid, asic=0),
        dict(row=_row, col=8, buf=_cli, asic=0),
        dict(row=_row, col=9, buf=_attached_dev, asic=0),
        dict(row=_row, col=10, buf=_port_name, asic=0),
        dict(row=_row, col=11, buf=_low_qos_l, asic=0),
        dict(row=_row, col=12, buf=_med_qos_l, asic=0),
        dict(row=_row, col=13, buf=_high_qos_l, asic=0),
    ]
    _slot_sheet_d['fixed_64']['port'].update({_port: _col_l_l.copy()})
    _row -= 1

# Fill in the _slot_sheet_d for 128 port fixed port switches.
_fixed_128_asic_map_d = {  # ToDo - These are not the correct ASIC numbers. This needs to get updated
    0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0,
    16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 0, 26: 0, 27: 0, 28: 0, 29: 0, 30: 0, 31: 0,
    32: 0, 33: 0, 34: 0, 35: 0, 36: 0, 37: 0, 38: 0, 39: 0, 40: 0, 41: 0, 42: 0, 43: 0, 44: 0, 45: 0, 46: 0, 47: 0,
    48: 0, 49: 0, 50: 0, 51: 0, 52: 0, 53: 0, 54: 0, 55: 0, 56: 0, 57: 0, 58: 0, 59: 0, 60: 0, 61: 0, 62: 0, 63: 0,
    64: 0, 65: 0, 66: 0, 67: 0, 68: 0, 69: 0, 70: 0, 71: 0, 72: 0, 73: 0, 74: 0, 75: 0, 76: 0, 77: 0, 78: 0, 79: 0,
    80: 0, 81: 0, 82: 0, 83: 0, 84: 0, 85: 0, 86: 0, 87: 0, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 95: 0,
    96: 0, 97: 0, 98: 0, 99: 0, 100: 0, 101: 0, 102: 0, 103: 0, 104: 0, 105: 0, 106: 0, 107: 0, 108: 0, 109: 0, 110: 0,
    111: 0, 112: 0, 113: 0, 114: 0, 115: 0, 116: 0, 117: 0, 118: 0, 119: 0, 120: 0, 121: 0, 122: 0, 123: 0, 124: 0,
    125: 0, 126: 0, 127: 0
}
_row = 131
for _port in range(0, 128):
    _col_l_l = [
        dict(row=_row, col=2, buf=_port_num, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=3, buf=_port_did, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=4, buf=_port_addr, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=5, buf=_port_index, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=6, buf=_port_link_addr_l, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=7, buf=_fid, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=8, buf=_cli, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=9, buf=_attached_dev, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=10, buf=_port_name, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=11, buf=_low_qos_l, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=12, buf=_med_qos_l, asic=_fixed_128_asic_map_d[_port]),
        dict(row=_row, col=13, buf=_high_qos_l, asic=_fixed_128_asic_map_d[_port]),
    ]
    _slot_sheet_d['fixed_128']['port'].update({_port: _col_l_l.copy()})
    _row -= 1

_fill_asic_d = {0: excel_fonts.fill_type('config_asic_0'), 1: excel_fonts.fill_type('config_asic_1')}

# Summary worksheet headers. First key is the column letter for the cell
_summary_sheet_d = dict(
    col=(10, 22, 98),
    chpid_d=dict(t='CHPIDs ($c)', h=('Tag', 'IOCP: CHPID', 'Ports Matching Link Addresses')),
    link_d=dict(t='Control Units ($c)', h=('Link Address', 'Type', 'CUNUM')),
    error_d=dict(t='Errors ($c)', h=('Area', 'Type', 'Description'))
)

# Configuration Worksheet
_switch_config_hdr = (
    dict(t='Area', c=20, align=_align_wrap),
    dict(t='Parameter', c=20, align=_align_wrap_c),
    dict(t='Comments', c=80, align=_align_wrap)
)
_dv_common_e = ' Please use pull down menu to pick an appropriate value.'  # Appended to all data validation error msgs
_dv_yn = DataValidation(type='list', formula1='"Yes,No"', allow_blank=False)
_dv_yn.errorTitle = 'Invalid Entry'
_dv_yn.error = 'Value must be "Yes" or "No".' + _dv_common_e
_dv_fid = DataValidation(type='list', formula1='lists!$B$2:$B$129', allow_blank=False)
_dv_fid.errorTitle = 'Invalid Entry'
_dv_fid.error = 'Invalid FID. FID must be an integer between 1-128.' + _dv_common_e
_dv_did = DataValidation(type='list', formula1='lists!$A$2:$A$240', allow_blank=False)
_dv_did.errorTitle = 'Invalid Entry'
_dv_did.error = 'Invalid DID. DID must be 0x01-0xEF.' + _dv_common_e
_dv_switch_type = DataValidation(type='list', formula1='"base,ficon,open"', allow_blank=False)
_dv_switch_type.errorTitle = 'Invalid Entry'
_dv_switch_type.error = 'Invalid switch type. Switch type must be base, ficon, or open' + _dv_common_e
_dv_fab_principal = DataValidation(type='list', formula1='lists!$D$2:$D$255', allow_blank=False)
_dv_fab_principal.errorTitle = 'Invalid Entry'
_dv_fab_principal.error = 'Invalid fabric priority. See FOS CLI fabricprincipal -priority for details.' + _dv_common_e
_dv_routing_policy = DataValidation(type='list', formula1='"default,DBR,EBR"', allow_blank=False)
_dv_routing_policy.errorTitle = 'Invalid Entry'
_dv_routing_policy.error = 'Invalid Routing Policy. Must be default, DBR, or EBR.' + _dv_common_e
_dv_port_name = DataValidation(type='list', formula1='"off,default,fdmi,dynamic,open -n,ficon -n"', allow_blank=False)
_dv_port_name.errorTitle = 'Invalid Entry'
_dv_port_name.error = 'Invalid Port Name. Must be off, default, fdmi, dynamic, open -n, or ficon -n.' + _dv_common_e
_dv_dup_wwn = DataValidation(type='list', formula1='"0,1,2"', allow_blank=False)
_dv_dup_wwn.errorTitle = 'Invalid Entry'
_dv_dup_wwn.error = 'Invalid duplicate WWN value. Value must be 0, 1, or 2.' + _dv_common_e


def _about_sheet(wb, sheet_index):
    """Inserts a worksheet into the workbook containing basic information and instructions

    :param wb: openpyxl Workbook
    :type wb: openpyxl class object
    :param sheet_index: Index as to where to start inserting worksheets
    :type sheet_index: int
    :return ec: Exit code
    :rtype ec: int
    """
    global _about_sheet_l

    # Add an "about" sheet
    sheet = wb.create_sheet(index=sheet_index, title='About')
    sheet.page_setup.paperSize = sheet.PAPERSIZE_LETTER
    sheet.column_dimensions['A'].width = 80

    row = col = 1
    for d in _about_sheet_l:
        if d is not None:
            excel_util.cell_update(sheet, row, col, d['t'], font=d['f'], align=_align_wrap)
        row += 1

    return brcddb_common.EXIT_STATUS_OK


def _create_workbook(folder, chassis_obj, sheet_l):
    """Create a switch configuration workbook for a chassis

    :param folder: Name of folder to put the workbooks in.
    :type folder: str
    :param chassis_obj: Chassis Object
    :type chassis_obj: brcddb_classes.chassis.ChassisObj
    :param sheet_l: Workbook template sheets read from excel_util.read_workbook()
    :type sheet_l: list
    :return wb: Excel workbook object
    :rtype wb: openpyxl.workbook.workbook.Workbook
    :return wb_name: Name of workbook, including folder path
    :rtype wb_name: str
    :return ec: Exit code
    :rtype ec: int
    """
    global _copy_sheets_d

    # Set up the workbook and add a switch configuration worksheet template for each switch by DID
    ec, rl = brcddb_common.EXIT_STATUS_OK, list()
    chassis_name = brcddb_chassis.best_chassis_name(chassis_obj)
    wb_name = folder + chassis_name.replace(':', '_') + '.xlsx'
    brcdapi_log.log('Creating Workbook: ' + wb_name, echo=True)
    wb = xl_wb.Workbook()

    # Insert the common sheets
    for sheet_name, d in _copy_sheets_d.items():
        rl.extend(excel_util.copy_worksheet(
            wb,
            0,  # Sheet index
            sheet_name,
            sheet_l,
            col_width_l=d.get('width_l'),
            font=d.get('font'),
            fill=d.get('fill'),
            border=d.get('border'),
            align=d.get('align'),
            hidden=d.get('hidden', False)
            )
        )
    if len(rl) > 0:
        brcdapi_log.log(rl, echo=True)
        ec = brcddb_common.EXIT_STATUS_ERROR

    return wb, wb_name, ec


def _add_chassis(wb, sheet_index, chassis_obj):
    """Create a switch configuration workbook for a chassis

    :param wb: Excel workbook object
    :type wb: openpyxl.workbook.workbook.Workbook
    :param sheet_index: Index sheet is to be inserted after
    :type sheet_index: int
    :param chassis_obj: Chassis Object
    :type chassis_obj: brcddb_classes.chassis.ChassisObj
    :return: Exit code
    :rtype: int
    """
    global _chassis_sheet_d, _std_font, _align_wrap, _border_thin, _bold_font

    # Create the chassis sheet and perform basic sheet setup
    sheet = wb.create_sheet(index=sheet_index, title='Chassis')
    sheet.page_setup.paperSize = sheet.PAPERSIZE_LETTER
    sheet.page_setup.orientation = sheet.ORIENTATION_LANDSCAPE
    col = 1
    for col_width in _chassis_sheet_d['width']:
        sheet.column_dimensions[xl.get_column_letter(col)].width = col_width
        col += 1

    # Add the headers & content
    row, col = 1, 1
    for d in _chassis_sheet_d['hdr']:
        excel_util.cell_update(
            sheet,
            row,
            col,
            d.get('buf'),
            font=d.get('font'),
            align=d.get('align'),
            border=d.get('border')
        )
        col += 1
    row, col = row + 1, 1
    excel_util.cell_update(
        sheet,
        row,
        col,
        'running/brocade-chassis/chassis',
        font=_bold_font,
        align=_align_wrap,
        border=_border_thin
    )
    sheet.merge_cells(start_row=row, start_column=col, end_row=row, end_column=len(_chassis_sheet_d['hdr']))
    row, col = row + 1, 1

    # Add the content
    chassis_name = brcddb_chassis.best_chassis_name(chassis_obj)
    excel_util.cell_update(sheet, row, col, chassis_name, font=_std_font, align=_align_wrap, border=_border_thin)
    if ':' in chassis_name:
        chassis_name = None
    for buf in ('chassis-user-friendly-name', chassis_name, 'Names the chassis. CLI equivalent: chassisname'):
        excel_util.cell_update(sheet, row, col, buf, font=_std_font, align=_align_wrap, border=_border_thin)
        col += 1

    return brcddb_common.EXIT_STATUS_OK


def _switch_config(wb, sheet_index, switch_obj, sheet_l):
    """Add a Switch_x worksheet to the workbook

    :param wb: openpyxl Workbook
    :type wb: openpyxl class object
    :param sheet_index: Index as to where this sheet should be placed in the Workbook
    :type sheet_index: int
    :param switch_obj: Switch object
    :type switch_obj: brcddb.classes.switch.SwitchObj
    :param sheet_l: Sheets for the template returned from excel_util.read_workbook
    :type sheet_l: list
    :return: Exit code
    :rtype: int
    """
    global _switch_config_hdr, _hdr1_font, _std_font, _border_thin, _align_wrap, _dv_yn, _dv_fid
    global _dv_did, _dv_switch_type, _dv_dup_wwn, _dv_fab_principal, _dv_routing_policy, _dv_port_name

    fabric_name = brcddb_fabric.best_fab_name(switch_obj.r_fabric_obj())
    switch_name = brcddb_switch.best_switch_name(switch_obj)
    did_hex = switch_obj.r_did()
    if isinstance(did_hex, int):
        did_hex = hex(did_hex).upper().replace('X', 'x')
    switch_type = 'open'
    insistent_did = 'Yes' if switch_obj.r_get(brcdapi_util.bfc_idid, False) else 'No'
    for port_obj in switch_obj.r_port_objects():
        if port_obj.r_get('rnid') is not None:
            switch_type = 'ficon'
            insistent_did = 'Yes'
            break
    port_name = 'default'  # ToDo - This isn't necessarily correct. Should use the port name configuration
    for port_obj in switch_obj.r_port_objects():
        if port_obj.r_port_name() is not None:
            port_name = 'ficon -n' if switch_type == 'ficon' else 'open -n'
            break
    for key, buf in {brcdapi_util.bfls_base_sw_en: 'base', brcdapi_util.bfls_ficon_mode_en: 'ficon'}.items():
        if switch_obj.r_get(key, False):
            switch_type = buf
            break
    try:
        apt_policy = _apt_policy_d.get(switch_obj.r_get(brcdapi_util.bfs_adv_tuning), 'default')
    except (ValueError, KeyError, TypeError):
        apt_policy = 'default'
    switch_config_d = {
        'Fabric ID (FID)': dict(p=switch_obj.r_fid(), dv=_dv_fid),
        'Fabric Name': dict(p=None if ':' in fabric_name else fabric_name),
        'Switch Name': dict(p=None if ':' in switch_name else switch_name),
        'Domain ID (DID)': dict(p=did_hex, dv=_dv_did),
        'Insistent DID': dict(p=insistent_did, dv=_dv_yn),
        'Fabric Principal Enable': dict(
            p='Yes' if switch_obj.r_get(brcdapi_util.bfc_principal_en, False) else 'No',
            dv=_dv_yn
        ),
        'Fabric Principal Priority': dict(
            p=switch_obj.r_get(brcdapi_util.bfc_principal_pri, '0x0A'),
            dv=_dv_fab_principal
        ),
        'Allow XISL': dict(p='Yes' if switch_obj.r_get(brcdapi_util.bfls_isl_enabled, False) else 'No', dv=_dv_yn),
        'Enable Switch': dict(p='No', dv=_dv_yn),
        'Enable Ports': dict(p='No', dv=_dv_yn),
        'Login Banner': dict(p=switch_obj.r_get(brcdapi_util.bfs_banner)),
        'Switch Type': dict(p=switch_type, dv=_dv_switch_type),
        'Duplicate WWN': dict(p=switch_obj.r_get(brcdapi_util.bfc_fport_enforce_login, 0), dv=_dv_dup_wwn),
        'Bind': dict(p='Yes' if switch_type == 'ficon' else 'No', dv=_dv_yn),
        'Routing Policy': dict(p=apt_policy, dv=_dv_routing_policy),
        'Port Name': dict(p=port_name, dv=_dv_port_name),
        'Port Name Format': dict(p=None),
        'Enable CUP': dict(p='Yes' if switch_obj.r_get(brcdapi_util.ficon_cup_en, False) else 'No', dv=_dv_yn),
    }

    # Add the worksheet and data validations
    sheet = wb.create_sheet(index=sheet_index, title='Switch_' + str(switch_obj.r_fid()))
    sheet.page_setup.paperSize = sheet.PAPERSIZE_LETTER
    sheet.page_setup.orientation = sheet.ORIENTATION_PORTRAIT
    for dv in (_dv_yn, _dv_fid, _dv_did, _dv_switch_type, _dv_dup_wwn, _dv_routing_policy, _dv_port_name,
               _dv_fab_principal):
        sheet.add_data_validation(dv)

    # Add the column headers
    row = col = 1
    for d in _switch_config_hdr:
        sheet.column_dimensions[xl.get_column_letter(col)].width = d['c']
        excel_util.cell_update(sheet, row, col, d['t'], font=_hdr1_font, align=d['align'], border=_border_thin)
        col += 1
    row, col = row + 1, 1

    # Find Switch_x and add the body
    for sheet_d in [sd for sd in sheet_l if str(sd.get('sheet')) == 'Switch_x']:
        for row_l in sheet_d['al'][1:]:
            d = switch_config_d.get(row_l[0], dict())
            excel_util.cell_update(  # Area
                sheet,
                row,
                col,
                row_l[0],
                font=_std_font,
                align=_align_wrap,
                border=_border_thin
            )
            col += 1
            excel_util.cell_update(  # Parameter
                sheet,
                row,
                col,
                d['p'],
                font=_std_font,
                align=_align_wrap_c,
                border=_border_thin
            )
            if d.get('dv') is not None:
                d['dv'].add(xl.get_column_letter(col) + str(row))
            col += 1
            excel_util.cell_update(  # Comments
                sheet,
                row,
                col,
                row_l[2],
                font=_std_font,
                align=_align_wrap,
                border=_border_thin
            )
            row, col = row + 1, 1

    return brcddb_common.EXIT_STATUS_OK


def _determine_slots(chassis_obj):
    """Determines the slot types and number of ports in each slot. Return is a list of dictionaries as follows:

    +-------+-------+-------------------------------------------+
    | Key   | Type  | Description                               |
    +=======+=======+===========================================+
    | slot  | int   | Slot number. 0 for fixed port switches.   |
    +-------+-------+-------------------------------------------+
    | type  | str   | Port card type. Key to _slot_sheet_d      |
    +-------+-------+-------------------------------------------+
    | ports | list  | List of port objects                      |
    +-------+-------+-------------------------------------------+

    :param chassis_obj: Chassis Object
    :type chassis_obj: brcddb_classes.chassis.ChassisObj
    :return: List of slot dictionaries. See function header description for details
    :rtype: list
    """
    chassis_name = brcddb_chassis.best_chassis_name(chassis_obj)

    # Figure out what ports go with which slot
    slot_d = dict()  # Key is the slot number. Value is a dictionary as specified in the function header
    for port_obj in chassis_obj.r_port_objects():
        sp_d = gen_util.slot_port_dict(port_obj.r_obj_key())
        sub_slot_d = slot_d.get(sp_d['slot'])
        if sub_slot_d is None:
            sub_slot_d = dict(slot=sp_d['slot'], ports=list())
            slot_d.update({sp_d['slot']: sub_slot_d})
        sub_slot_d['ports'].append(port_obj)

    sw_blade_type_d = {  # Used to determine what the blade type is
        'sw blade': {'skip': False, 'supported': True, 48: 'pc_48', 64: 'pc_64'},
        'core blade': {'skip': False, 'supported': True, 32: 'core_4', 64: 'core_8'},
        'cp blade': dict(skip=True, supported=True),
        'ap blade': dict(skip=True, supported=False),
        'None': dict(skip=True, supported=False),
    }

    product_name = chassis_obj.r_get(brcdapi_util.bc_product_name)

    if not isinstance(product_name, str):
        brcdapi_log.log(brcdapi_util.bc_product_name + ' missing in chassis ' + chassis_name, echo=True)
        raise TypeError

    for blade_d in chassis_obj.r_get(brcdapi_util.fru_blade, list()):
        slot_num = blade_d['slot-number']
        blade_type = blade_d.get('blade-type', 'None')
        if blade_type not in sw_blade_type_d:
            blade_type = 'None'
        try:
            sub_slot_d = slot_d.get(slot_num)
            if sub_slot_d is None:
                slot_d.update({slot_num: dict(slot=slot_num, ports=list())})
            if slot_num == 0:
                slot_d[slot_num]['type'] = 'fixed_64' if blade_d['fc-port-count'] == 64 else 'fixed_128'
                continue  # This is effectively a break in fixed port switches.
            blade_type_d = sw_blade_type_d.get(blade_type)
            if blade_type_d['supported']:
                if blade_type_d['skip']:
                    if slot_num in slot_d:
                        slot_d.pop(slot_num)
                    continue
                blade_type_key = sw_blade_type_d[blade_type].get(blade_d['fc-port-count'])
                if blade_type_key is None:
                    raise Found
                slot_d[blade_d['slot-number']]['type'] = blade_type_key
            else:
                raise Found
        except Found:
            buf = 'Unsupported blade type: ' + blade_type + ' in slot ' + str(slot_num) + chassis_name
            buf += '. Skipping.'
            if slot_num in slot_d:
                slot_d.pop(slot_num)
            brcdapi_log.log(buf, echo=False)

    if len(slot_d) == 0:
        brcdapi_log.log(brcdapi_util.fru_blade + ' missing, empty, or no supported blade types in ' + chassis_name,
                        echo=True)
        raise TypeError

    slot_d_key_l = [int(key) for key in slot_d.keys()]
    slot_d_key_l.sort()  # Although not necessary, humans like to see the workbook with slots in order

    return [slot_d[key] for key in slot_d_key_l]


def _add_slot(wb, sheet_index, slot, slot_type, port_obj_l):
    """Adds a port slot sheet to the workbook

    :param wb: Excel workbook object
    :type wb: openpyxl.workbook.workbook.Workbook
    :param sheet_index: Index sheet is to be inserted after
    :type sheet_index: int
    :param slot: Slot number
    :type slot: int
    :param slot_type: xxx
    :type slot_type: str
    :return ec: Exit code
    :rtype ec: int
    """
    global _slot_sheet_d, _white_bold_font, _align_wrap_c, _fill_slot, _border_thin, _std_font, _fill_asic_d

    # Debug
    global _debug_i

    ec = brcddb_common.EXIT_STATUS_OK

    # Create the slot sheet and perform basic sheet setup
    title = 'Slot ' + str(slot)
    sheet = wb.create_sheet(index=sheet_index, title=title)
    sheet.page_setup.paperSize = sheet.PAPERSIZE_LETTER
    sheet.page_setup.orientation = sheet.ORIENTATION_LANDSCAPE
    row, col = 1, 2
        
    # Add the slot number in the first row
    excel_util.cell_update(
        sheet,
        row,
        col,
        title.upper(),
        font=_white_bold_font,
        align=_align_wrap_c,
        fill=_fill_slot,
        border=_border_thin)
    sheet.merge_cells(start_row=row, start_column=col, end_row=row, end_column=len(_slot_sheet_d[slot_type]['hdr']))

    # Add the headers and set the column width
    row, col = row + 1, 1
    for d in _slot_sheet_d[slot_type]['hdr']:
        sheet.column_dimensions[xl.get_column_letter(col)].width = d['col']
        excel_util.cell_update(
            sheet,
            row,
            col,
            d.get('buf'),
            font=d.get('font'),
            align=d.get('align'),
            fill=d.get('fill'),
            border=d.get('border'))
        col += 1

    # Add the ports
    for port_obj in port_obj_l:

        # Get the control dictionary to determine where and how to display this port
        try:
            port_l = _slot_sheet_d[slot_type]['port'][int(port_obj.r_obj_key().split('/')[1])]
        except (ValueError, TypeError, IndexError, KeyError):
            brcdapi_log.log('Programming error encountered. Check the log for details.', echo=True)
            brcdapi_log.exception(['slot_type: ' + slot_type] + class_util.format_obj(port_obj))
            ec = brcddb_common.EXIT_STATUS_ERROR
            continue

        # Add the port to the worksheet
        for d in port_l:
            excel_util.cell_update(
                sheet,
                d['row'],
                d['col'],
                d['buf'](port_obj, d['row']),
                font=d.get('font', _std_font),
                align=d.get('align', _align_wrap_c),
                fill=_fill_asic_d[d['asic']],
                border=d.get('border', _border_thin))

    return ec


def psuedo_main(folder, proj_obj, sheet_l):
    """Basically the main(). Did it this way so that it can easily be used as a standalone module or called from another

    :param folder: Name of folder to put the workbooks in.
    :type folder: str
    :param proj_obj: Project object. If None, an error was encountered.
    :type proj_obj: None, brcddb.classes.project.ProjectObj
    :param sheet_l: Workbook template sheets read from excel_util.read_workbook()
    :type sheet_l: list
    :return: Exit code. See exist codes in brcddb.brcddb_common
    :rtype: int
    """
    global __version__

    ec_l = [brcddb_common.EXIT_STATUS_OK]

    for chassis_obj in proj_obj.r_chassis_objects():

        # Create the workbook
        wb, wb_name, temp_ec = _create_workbook(folder, chassis_obj, sheet_l)
        ec_l.append(temp_ec)
        sheet_index = 1

        # Insert the "About" worksheet
        buf_l = (
            'The contents of this Workbook were generated from a script that reads a data collection file and '
            'generates a standard switch configuration workbook.',
            '',
            'The intended uses are:',
            '  *   Graphical documentation depicting where connections are made.',
            '  *   To be modified for use with switch_config.py.',
            '  *   A planning tool to aid in determining physical switch ports for device connections.',
        )
        report_utils.about_page(wb, sheet_index, 'About', os.path.basename(__file__),  __version__, buf_l)
        sheet_index += 1

        # Add the chassis sheet
        ec_l.append(_add_chassis(wb, sheet_index, chassis_obj))
        sheet_index += 1

        # Add the switch configuration worksheets
        for switch_obj in chassis_obj.r_switch_objects():
            _switch_config(wb, sheet_index, switch_obj, sheet_l)
            sheet_index += 1

        # Add the slot worksheets
        try:
            for slot_d in _determine_slots(chassis_obj):
                ec_l.append(_add_slot(wb, sheet_index, slot_d['slot'], slot_d['type'], slot_d['ports']))
                sheet_index += 1
        except TypeError:
            return brcddb_common.EXIT_STATUS_INPUT_ERROR

        # Save the workbook
        try:
            wb.save(wb_name)
        except FileNotFoundError:
            brcdapi_log.log('The folder in ' + wb_name + ' does not exist.', echo=True)
            ec_l.append(brcddb_common.EXIT_STATUS_ERROR)
        except PermissionError:
            buf = 'Write permission for ' + wb_name + ' denied. This is typically due to the file being opened.'
            brcdapi_log.log(buf, echo=True)
            ec_l.append(brcddb_common.EXIT_STATUS_ERROR)

    return max(ec_l)


def _get_input():
    """Gets the shell invocation parameters, validates input, opens log file, gets project object, gets switch map

    :return: Exit code. See exist codes in brcddb.brcddb_common
    :rtype: int
    """
    global __version__, _input_

    # Get command line input
    buf = 'Creates switch configuration workbooks for each chassis found in a project. WARNING: The ASIC '\
          'number is not correct with 128 port fixed port switches and CLI port configurations have not been filled in.'
    args_d = gen_util.get_input(buf, _input_d)

    # Set up logging
    brcdapi_log.open_log(
        folder=args_d['log'],
        suppress=args_d['sup'],
        no_log=args_d['nl'],
        version_d=brcdapi_util.get_import_modules()
    )

    # User feedback
    ml = [
        os.path.basename(__file__) + ', ' + __version__,
        'In file, -i:         ' + args_d['i'],
        'Out folder, -o:      ' + args_d['o'],
        'Log, -log:           ' + str(args_d['log']),
        'No log, -nl:         ' + str(args_d['nl']),
        'Suppress, -sup:      ' + str(args_d['sup']),
        '',
    ]
    brcdapi_log.log(ml, echo=True)

    # Read the project file, -i
    in_file = brcdapi_file.full_file_name(args_d['i'], '.json')
    try:
        proj_obj = brcddb_project.read_from(in_file)
        if proj_obj is None:  # Error messages are sent to the log in brcddb_project.read_from() if proj_obj is None
            return brcddb_common.EXIT_STATUS_INPUT_ERROR
    except FileNotFoundError:
        brcdapi_log.log('Input file, ' + in_file + ', not found', echo=True)
        return brcddb_common.EXIT_STATUS_INPUT_ERROR
    except (FileExistsError, FileNotFoundError):
        brcdapi_log.log('Folder in ' + in_file + ' does not exist', echo=True)
        return brcddb_common.EXIT_STATUS_INPUT_ERROR
    proj_obj.s_description('\n'.join(ml))

    # Find the most recent switch configuration template. Only chassis, VC, and list sheets are used, so any one will do
    most_recent_file_d = dict(st_mtime=0)
    file_l = list()
    for folder in ('./', 'templates/'):
        for file in gen_util.match_str(brcdapi_file.read_directory(folder=folder),
                                       'Fixed_Port_Switch_Configuration*.xlsx',
                                       stype='wild'):
            file_d = brcdapi_file.file_properties(folder, file)
            file_d['folder'] = folder
            file_l.append(file_d)
    for file_d in file_l:
        if file_d['st_mtime'] > most_recent_file_d['st_mtime']:
            most_recent_file_d = file_d
    if most_recent_file_d['st_mtime'] == 0:
        buf_l = [
            'A switch configuration template named "Fixed_Port_Switch_Configuration*.xlsx" must exist in the directory '
            'where this script was run from or in a sub-folder named "templates". The most recently modified file '
            'with this naming convention is required because the common worksheets, such as "Instructions", are copied '
            'for use in the output file (-o).',
            '',
            'Switch configuration templates are available at:',
            'https://github.com/jconsoli/brocade-rest-api-applications',
            '',
            ]
        brcdapi_log.log(buf_l, echo=True)
        return brcddb_common.EXIT_STATUS_INPUT_ERROR

    # Read the template workbook
    file = most_recent_file_d['folder'] + most_recent_file_d['name']
    ml, sheets_l = excel_util.read_workbook(file, dm=3, order='col', skip_sheets=_skip_sheets)
    if len(ml) > 0:
        brcdapi_log.log(ml, echo=True)
        return brcddb_common.EXIT_STATUS_INPUT_ERROR

    # Create the folder
    folder = args_d['o']
    if len(args_d['o']) > 0:
        try:
            os.mkdir(folder)
            folder += '/'
        except (FileExistsError, FileNotFoundError):
            folder += '/'
        except FileNotFoundError:
            brcdapi_log.log('A sub-folder in ' + folder + ' does not exist. Only the last folder can be created.',
                            echo=True)
            return brcddb_common.EXIT_STATUS_INPUT_ERROR

    return psuedo_main(folder, proj_obj, sheets_l)


##################################################################
#
#                    Main Entry Point
#
###################################################################

# Read in the project file from which the report is to be created and convert to a project object
# Create project

if _DOC_STRING:
    print('_DOC_STRING is True. No processing')
    exit(brcddb_common.EXIT_STATUS_OK)
else:
    _ec = _get_input()
    brcdapi_log.close_log('Processing complete with ending status: ' + str(_ec), echo=True)
    exit(_ec)
