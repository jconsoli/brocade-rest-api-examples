#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Copyright 2023, 2024, 2025 Consoli Solutions, LLC.  All rights reserved.

**License**

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
the License. You may also obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
language governing permissions and limitations under the License.

The license is free for single customer use (internal applications). Use of this module in the production,
redistribution, or service delivery for commerce requires an additional license. Contact jack@consoli-solutions.com for
details.

**Description**

Creates a report in Excel Workbook format with all differences between two content samples

**Version Control**

+-----------+---------------+---------------------------------------------------------------------------------------+
| Version   | Last Edit     | Description                                                                           |
+===========+===============+=======================================================================================+
| 4.0.0     | 04 Aug 2023   | Re-Launch                                                                             |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 4.0.1     | 06 Mar 2024   | Fixed potential for invalid sheet names.                                              |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 4.0.2     | 03 Apr 2024   | Added version numbers of imported libraries.                                          |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 4.0.3     | 06 Dec 2024   | Updated comments only.                                                                |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 4.0.4     | 01 Mar 2025   | Error message enhancements.                                                           |
+-----------+---------------+---------------------------------------------------------------------------------------+
| 4.0.5     | 25 Aug 2025   | Use brcddb.util.util.get_import_modules to dynamically determined imported libraries. |
+-----------+---------------+---------------------------------------------------------------------------------------+
"""
__author__ = 'Jack Consoli'
__copyright__ = 'Copyright 2024, 2025 Consoli Solutions, LLC'
__date__ = '25 Aug 2025'
__license__ = 'Apache License, Version 2.0'
__email__ = 'jack_consoli@yahoo.com'
__maintainer__ = 'Jack Consoli'
__status__ = 'Released'
__version__ = '4.0.5'

import os
import brcdapi.log as brcdapi_log
import brcdapi.gen_util as gen_util
import brcdapi.file as brcdapi_file
import brcdapi.excel_util as excel_util
import brcdapi.util as brcdapi_util
import brcddb.brcddb_fabric as brcddb_fabric
import brcddb.brcddb_switch as brcddb_switch
import brcddb.brcddb_chassis as brcddb_chassis
import brcddb.util.compare as brcddb_compare
import brcddb.brcddb_project as brcddb_project
import brcddb.brcddb_common as brcddb_common
import brcddb.report.utils as report_utils
import brcddb.app_data.report_tables as brcddb_rt

_DOC_STRING = False  # Should always be False. Prohibits any code execution. Only useful for building documentation
# _STAND_ALONE: True: Executes as a standalone module taking input from the command line. False: Does not automatically
# execute. This is useful when importing this module into another module that calls psuedo_main().
_STAND_ALONE = True  # See note above

# Input parameter definitions
_input_d = dict(
    b=dict(h='Required. Base project to compare against. Typically the older data. Name of input file generated by '
             'capture.py or combine.py. ".json" is automatically appended.'),
    c=dict(h='Required. Project to compare against. Typically the newer data. Name of input file generated by '
             'capture.py or combine.py. ".json" is automatically appended.'),
    r=dict(h='Required. Excel comparison report file name. ".xlsx" is automatically appended.')
)
_input_d.update(gen_util.parseargs_log_d.copy())

_key_conv_tbl = dict()  # List of API keys converted to human-readable format for report display
_generic_table_add = (  # Key to add to _key_conv_tbl that are simple key/values in brcddb.app_data.report_tables
    brcddb_rt.Chassis.chassis_display_tbl,
    brcddb_rt.Fabric.fabric_display_tbl,
    brcddb_rt.Switch.switch_display_tbl,
    brcddb_rt.Chassis.chassis_display_tbl,
    brcddb_rt.Security.security_display_tbl,
    brcddb_rt.Zone.zone_display_tbl,
)

"""We don't want to clutter the report with expected changes such as time-awake, or minor changes such as a few uW
difference in Tx power. The keys in these tables are used as a RegEx search. Keys in dict() are as follows:
+-------|-----------------------------------------------------------------------------------------------------------|
| Key   | Description                                                                                               |
+=======+===========================================================================================================|
| skip  | True - do not perform any checking on matching keys.                                                      |
+-------|-----------------------------------------------------------------------------------------------------------|
| lt    | Only used for numeric comparisons. The item is marked as changed if the compare object + this value is    |
|       | less  than the base value.                                                                                |
+-------|-----------------------------------------------------------------------------------------------------------|
| gt    | Same as lt except compare object + this value is greater than the base value.                             |
+-------|-----------------------------------------------------------------------------------------------------------|
"""
_control_tables = dict(  # Keys are the objects defined in brcddb.classes
    ProjectObj={
        '/_(obj_key|alerts)': dict(skip=True),
    },
    ChassisObj={
        '/_(obj_key|project_obj|alerts)': dict(skip=True),
        '/brocade-chassis/chassis/date': dict(skip=True),
        '/brocade-chassis/management-port-connection-statistics': dict(skip=True),
        '/brocade-fru/fan/speed': dict(lt=500, gt=500),
        '/brocade-fru/fan/time-(awake|alive)': dict(skip=True),
        '/brocade-fru/power-supply/time-(awake|alive)': dict(skip=True),
        '/brocade-fru/power-supply/temperature': dict(lt=5, gt=5),
        '/brocade-fru/power-supply/power-usage': dict(lt=50, gt=50),
        '/brocade-fru/power-supply/input-voltage': dict(lt=10, gt=10),
        '/brocade-fru/power-supply/last-header-update-date': dict(skip=True),
        '/brocade-fru/blade/power-usage': dict(lt=10, gt=10),
        '/brocade-fru/blade/time-(alive|awake)': dict(skip=True),
        '/brocade-fru/blade/last-header-update-date': dict(skip=True),
        '/brocade-fru/sensor/temperature': dict(lt=5, gt=5),
        '/brocade-fru/wwn/time-(alive|awake)': dict(skip=True),
        '/brocade-fru/wwn/time-alive/time-awake': dict(skip=True),
        '/brocade-fru/wwn/last-header-update-date': dict(skip=True),
        '/brocade-fru/fan/last-header-update-date': dict(skip=True),
        '/brocade-logging': dict(skip=True),
        '/brocade-supportlink': dict(skip=True),
        '/management-ethernet-interface': dict(skip=True),
        '/brocade-management-ip-interface': dict(skip=True),
    },
    FabricObj={
        '/_(obj_key|project_obj|alerts|base_logins|port_map)': dict(skip=True),
        '/brocade-zone/(.*)': dict(skip=True),  # Everything in brocade-zone is already in the object
        # The number of fpin notifications is fabric dependent. 20 is somewhat arbitrary
        '/brocade-fabric-traffic-controller/fabric-traffic-controller-device/fpin-send-statistics/congestion-count':
            dict(lt=0, gt=0),
        '/brocade-traffic-optimizer/performance-group/aggregate-iops': dict(skip=True),
        '/brocade-traffic-optimizer/performance-group/aggregate-throughput': dict(skip=True),
        # It wasn't clear what max-io-latency represented in the 9.1.1 Rest API Guide. I'm assuming it's 2.5 usec ticks,
        # so 400,000 = 1 sec. The maximum I/O latency is fabric dependent. 80,000 ticks (20 msec) is somewhat arbitrary
        '/brocade-traffic-optimizer/performance-group/max-io-latency': dict(lt=80000, gt=80000),
    },
    ZoneCfgObj={'/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True)},
    LoginObj={'/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True)},
    FdmiNodeObj={'/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True)},
    FdmiPortObj={'/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True)},
    ZoneObj={'/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True)},
    AliasObj={'/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True)},
    SwitchObj={
        '/_(obj_key|project_obj|alerts|flags|fabric_key|reserved_keys)': dict(skip=True),
        'brocade-fibrechannel-logical-switch/fibrechannel-logical-switch/(port|ge-port)-member-list/port-member':
            dict(skip=True),
        '/brocade-fibrechannel-switch/fibrechannel-switch/up-time': dict(skip=True),
        '/brocade-fibrechannel-switch/fibrechannel-switch/enabled-state': dict(skip=True),  # Deprecated
        '/brocade-fabric/fabric-switch/fcid': dict(skip=True),  # Deprecated
        '/brocade-maps/dashboard-rule': dict(skip=True),
        '/brocade-maps/dashboard-rule/category': dict(skip=True),
        '/brocade-maps/dashboard-rule/name': dict(skip=True),
        '/brocade-maps/dashboard-history': dict(skip=True),
        '/brocade-maps/dashboard-rule/objects/object': dict(skip=True),
        '/brocade-maps/dashboard-rule/objects/repetition-count': dict(skip=True),
        '/brocade-maps/dashboard-rule/objects/time-stamp': dict(skip=True),
        '/brocade-maps/dashboard-rule/objects/triggered-count': dict(skip=True),
        '/brocade-maps/oversubscription-dashboard': dict(skip=True),
        '/brocade-maps/credit-stall-dashboard': dict(skip=True),
        'brocade-maps/group/members/member': dict(skip=True),
        'brocade-maps/system-resources/cpu-usage': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/tx-percentage': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/tx-throughput': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/rx-throughput': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/rx-throughput/txrx-throughput': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/txrx-throughput': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/txrx-percentage': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/rx-percentage': dict(skip=True),
        '/brocade-fibrechannel-trunk/performance/rx-percentage/txrx-percentage': dict(skip=True),
        'brocade-logging/raslog/(current|default)-severity': dict(skip=True),
        'brocade-logging/raslog/current-severity/default-severity': dict(skip=True),
        'brocade-logging/raslog/message-id': dict(skip=True),
        'fos_cli/portcfgshow_raw': dict(skip=True),
        'fos_cli/portbuffershow': dict(skip=True),
        'fos_cli/portcfgshow': dict(skip=True),
        'brocade-fibrechannel-logical-switch/fibrechannel-logical-switch/port-index-members/port-index':
            dict(skip=True),
    },
    PortObj={
        '/_(obj_key|project_obj|alerts|sfp_thresholds|maps_fc_port_group|flags|switch|reserved_keys)': dict(skip=True),
        '/fibrechannel/fcid': dict(skip=True),  # Deprecated
        '/fibrechannel/enabled-state': dict(skip=True),  # Deprecated
        '/fibrechannel/average-(receive|transmit)-frame-size': dict(skip=True),
        '/fibrechannel/average-(receive|transmit)-buffer-usage': dict(skip=True),
        '/fibrechannel-statistics/time-(generated|refreshed)': dict(skip=True),
        '/fibrechannel-statistics/total-(up|down|offline)-time': dict(skip=True),
        '/fibrechannel-statistics/(tx|rx)-peak-frame': dict(skip=True),
        '/fibrechannel-statistics/class-3-frames': dict(skip=True),
        '/fibrechannel-statistics/(in|out)-(rate|octets|frames)': dict(skip=True),
        '/fibrechannel-statistics/(in|out)-(frame|max-frame|peak)-rate': dict(skip=True),
        '/fibrechannel-statistics/frames-processing-required': dict(skip=True),  # What is this?
        '/media-rdp/temperature': dict(lt=5, gt=5),
        '/media-rdp/current': dict(lt=0.2, gt=0.2),
        '/media-rdp/(r|t)x-power': dict(lt=25, gt=25),
        '/media-rdp/voltage': dict(lt=20, gt=20),
        '/media-rdp/power-on-time': dict(skip=True),
        '/media-rdp/remote-media-signal-loss/(up|down)-stream': dict(lt=25, gt=25),
        '/media-rdp/remote-media-temperature': dict(lt=5, gt=5),
        '/media-rdp/remote-media-current': dict(lt=0.2, gt=0.2),
        '/media-rdp/remote-media-(r|t)x-power': dict(lt=20, gt=20),
        '/media-rdp/remote-media-voltage': dict(lt=20, gt=20),
        '/media-rdp/remote-media-(voltage|temperature|tx-bias|tx-power|rx-power)-alert/(high|low)-(warning|alarm)':
            dict(skip=True),  # These remote media values aren't always valid
        'media-rdp/last-poll-time': dict(skip=True),  # Poll time?
    },
    AlertObj={'/msg_tbl': dict(skip=True)},
)

_column_names = dict(
    _flags='Flag',
    _port_objs='FC Port',
    _ge_port_objs='GE Port',
    _maps_rules='MAPS Rule',
    _maps_group_rules='MAPS Group Rule',
    _maps_groups='MAPS Group',
    _login_objs='Login',
    _zonecfg_objs='Zone Configuration',
    _alias_objs='Alias',
    _zone_objs='Zone',
    _eff_zone_objs='Effective Zone Member',
    _fdmi_node_objs='FDMI Node',
    _fdmi_port_objs='FDMI Port',
    _fabric_objs='Fabric'
)


def _format_disp(fk, obj):
    """Converts API keys to human-readable format

    :param fk: List of keys to convert
    :type obj: list
    :param obj: Change object
    :type obj: dict
    :return: List of keys in human-readable format for report
    :type: list
    """
    # I have no idea what I was thinking when I did this. It works but it's ugly

    global _key_conv_tbl

    b, c = obj.get('b'), obj.get('c')
    tfk = fk.copy()
    if len(tfk) == 2 and tfk[0] == '_port_objs':
        key = 'Port'
    elif len(tfk) > 2 and tfk[0] == '_port_objs':
        tfk[1] = 's/p'
        key = '/'.join(tfk)
        if key in _key_conv_tbl:
            key = 'Port ' + fk[1] + ' ' + _key_conv_tbl[key]
        else:
            key = 'Port ' + fk[1] + '/' + fk[2] + ' ' + '/'.join(tfk[3:])
        try:
            b = str(brcddb_common.port_conversion_tbl[tfk[3]][int(b)])
            c = str(brcddb_common.port_conversion_tbl[tfk[3]][int(c)])
        except (ValueError, KeyError, IndexError):
            try:
                b = str(brcddb_common.port_conversion_tbl[tfk[3]][b])
                c = str(brcddb_common.port_conversion_tbl[tfk[3]][c])
            except (KeyError, IndexError):
                b = obj.get('b')
                c = obj.get('c')
    elif len(tfk) > 2 and tfk[0] == 'brocade-fibrechannel-switch' and tfk[1] == 'fibrechannel-switch':
        key = '/'.join(tfk)
        try:
            b = str(brcddb_common.switch_conversion_tbl[key][int(b)])
            c = str(brcddb_common.switch_conversion_tbl[key][int(c)])
        except (ValueError, KeyError, IndexError):
            b, c = obj.get('b'), obj.get('c')
        if key in _key_conv_tbl:
            key = _key_conv_tbl[key]
    else:
        key = '/'.join(tfk)
        if isinstance(key, str) and key in _key_conv_tbl:
            key = _key_conv_tbl[key]

    return [key, b, c, obj.get('r')]


def _content_append(obj, content):
    """Checks to makes sure we're not adding null content

    :param obj: Object to add
    :type obj: dict
    :param content: List of report content where obj is to be added
    :type content: list
    """
    dl = obj.get('disp')
    if dl is not None and len(dl) == 4:
        if dl[1] is not None and dl[2] is not None:
            content.append(obj)
    else:
        content.append(obj)


def _fabric_name(p_obj, wwn, flag=True):
    return brcddb_fabric.best_fab_name(p_obj.r_fabric_obj(wwn), wwn=flag, fid=flag)


def _chassis_name(p_obj, wwn, flag=True):
    return brcddb_chassis.best_chassis_name(p_obj.r_chassis_obj(wwn), wwn=flag)


def _switch_name(p_obj, wwn, flag=True):
    return brcddb_switch.best_switch_name(p_obj.r_switch_obj(wwn), wwn=flag, did=True)


def _port_name(p_obj, wwn, flag=True):
    return


def _basic_add_to_content(obj, b_obj, c_obj, content):
    """Parses a dictionary returned from brcddb.util.compare.compare

    :param obj: Fabric object to parse
    :type obj: dict
    :param b_obj: Base project object. Not used
    :type b_obj: brcddb.classes.project.*Obj
    :param c_obj: Compare project object. Not used
    :type c_obj: brcddb.classes.project.*Obj
    :param content: List of report content where objects in obj are to be added
    :type content: list
    """
    start = len(content)
    if obj is not None:
        for k, v in obj.items():
            _content_append(dict(font='std', align='wrap', disp=('', v.get('b'), v.get('c'), v.get('r'))), content)
    if len(content) == start:
        content.append(dict(merge=4, font='std', align='wrap', disp=('No changes',)))


def _alias_add_to_content(obj, b_obj, c_obj, content):
    """Same as _basic_add_to_content() but assumes the data are WWNs and converts them to aliases"""
    start = len(content)
    if obj is not None:
        for k, v in obj.items():
            b_buf = v.get('b')
            alias = b_obj.r_alias_for_wwn(b_buf)
            if len(alias) > 0:
                b_buf = alias[0] + ' (' + b_buf + ')'
            c_buf = v.get('c')
            alias = c_obj.r_alias_for_wwn(c_buf)
            if len(alias) > 0:
                c_buf = alias[0] + ' (' + c_buf + ')'
            _content_append(dict(font='std', align='wrap', disp=('', b_buf, c_buf, v.get('r'))), content)
    if len(content) == start:
        content.append(dict(merge=4, font='std', align='wrap', disp=('No changes',)))


def _zoneobj_add_to_content(obj, b_obj, c_obj, content):
    """Same as _basic_add_to_content() but assumes the data are WWNs and converts them to aliases"""
    start = len(content)
    if obj is not None:
        for k, v in obj.items():
            buf = str(k)
            mem_d_l = gen_util.convert_to_list(v.get('_members', v if isinstance(v, dict) else list()))
            # mem_d_l = v['_members'] if '_members' in v else [v] if isinstance(v, dict) else list()
            for mem_d in mem_d_l:
                _content_append(dict(font='std', align='wrap', disp=(buf, mem_d['b'], mem_d['c'], mem_d['r'])), content)
                buf = ''
            for mem_d in gen_util.convert_to_list(v.get('_pmembers')):
                _content_append(dict(font='std', align='wrap', disp=(buf, mem_d['b'], mem_d['c'], mem_d['r'])), content)
                buf = ''
    if len(content) == start:
        content.append(dict(merge=4, font='std', align='wrap', disp=('No changes',)))


def _switch_add_to_content(obj, b_obj, c_obj, content):
    """Same as _basic_add_to_content() except obj is a list of switch change objects"""
    start = len(content)
    for change_obj in [t_obj for t_obj in obj if t_obj.get('r') is not None]:
        b_buf = brcddb_switch.best_switch_name(b_obj.r_project_obj().r_switch_obj(change_obj.get('b')),
                                               wwn=True, did=True)
        c_buf = brcddb_switch.best_switch_name(c_obj.r_project_obj().r_switch_obj(change_obj.get('c')),
                                               wwn=True, did=True)
        _content_append(dict(font='std', align='wrap', disp=('', b_buf, c_buf, change_obj.get('r'))), content)
    if len(content) == start:
        content.append(dict(merge=4, font='std', align='wrap', disp=('No changes',)))


def _fabric_add_to_content(obj, b_obj, c_obj, content):
    """Same as _basic_add_to_content() but assumes the data are WWNs and converts them to fabric names"""
    start = len(content)
    if obj is not None:
        proj_obj = obj.r_project_obj()
        for k, v in obj.items():
            b_buf = brcddb_fabric.best_fab_name(proj_obj.r_fabric_obj(v.get('b')), wwn=True, fid=True)
            c_buf = brcddb_fabric.best_fab_name(proj_obj.r_fabric_obj(v.get('c')), wwn=True, fid=True)
            _content_append(dict(font='std', align='wrap', disp=('', b_buf, c_buf, v.get('r'))), content)
    if len(content) == start:
        content.append(dict(merge=4, font='std', align='wrap', disp=('No changes',)))


def _null(obj, b_obj, c_obj, content):
    """Used for development before comparisons are complete for an item"""
    return


_action_table = dict(
    _fabric_objs=dict(
        _alias_objs=dict(t='Aliases', f=_alias_add_to_content),
        _eff_zone_objs=dict(t='Zones in effective zones configuration', f=_basic_add_to_content),
        _fdmi_node_objs=dict(t='FDMI Nodes', f=_alias_add_to_content),
        _fdmi_port_objs=dict(t='FDMI Ports', f=_alias_add_to_content),
        _login_objs=dict(t='Name server logins', f=_alias_add_to_content),
        _switch_keys=dict(t='Switches in fabric', f=_switch_add_to_content),
        _zone_objs=dict(t='Zones', f=_zoneobj_add_to_content),
        _zonecfg_objs=dict(t='Zone configurations', f=_zoneobj_add_to_content),
    ),
    _chassis_objs=dict(
        _switch_keys=dict(t='Switches in fabric', f=_switch_add_to_content),
    ),
    _switch_objs=dict(
        _fabric_key=dict(t='Member of Fabric', f=_fabric_add_to_content),
        _maps_rules=dict(t='MAPS Rules', f=_basic_add_to_content),
        # _maps_group_rules=dict(t='MAPS Group Rules', f=_basic_add_to_content),
        _maps_group_rules=dict(t='MAPS Group Rules', f=_null),
        _maps_groups=dict(t='MAPS Groups', f=_basic_add_to_content),
    ),
)


def _api_added_compares(obj, k, fk, content):
    """Recursively iterates through a list of changes from compare.compare() for API added content

    :param obj: Added API content or list of API content objects
    :type obj: dict, list, tuple
    :param k: Active key
    :type k: str
    :param fk: List of keys
    :type fk: list
    :param content: Running list of changes to add to report
    :type content: list
    """
    if isinstance(obj, dict):
        t_obj = obj.get(k)
        if isinstance(t_obj, dict):
            fk.append(k)
            for k1 in t_obj.keys():
                _api_added_compares(t_obj, k1, fk.copy(), content)
        elif isinstance(t_obj, (list, tuple)):
            _api_added_compares(t_obj, k, fk, content)
        elif isinstance(t_obj, (str, int, float)):
            if k == 'b':
                _content_append(dict(font='std', align='wrap', disp=_format_disp(fk, obj)), content)
            elif k not in ('c', 'r'):
                brcdapi_log.exception('Unknown element: ' + str(t_obj), echo=True)
        else:
            brcdapi_log.exception('Unknown type: ' + str(type(t_obj)), echo=True)

    elif isinstance(obj, (list, tuple)):
        fk.append(k)
        for i in range(0, len(obj)):
            n_obj = obj[i]
            if isinstance(n_obj, dict):
                for k1 in n_obj.keys():
                    if '[' in fk[len(fk)-1]:
                        fk.pop()
                    fk.append('[' + str(i) + ']')
                    _api_added_compares(n_obj, k1, fk.copy(), content)

    else:
        brcdapi_log.exception('Unknown type: ' + str(type(obj)), echo=True)


def _project_page(wb, sheet_index, b_proj_obj, c_proj_obj, c_obj):
    """Recursively iterates through a list of changes from compare.compare() for fabric. Create fabric pages as needed

    :param wb: Workbook object
    :type wb: dict
    :param sheet_index: Starting sheet index
    :type sheet_index: int
    :param b_proj_obj: Project object for base (project we are comparing against). Typically, the older project.
    :type b_proj_obj: brcddb.classes.project.ProjectObj
    :param c_proj_obj: Comparison project object. Typically, the newer project.
    :type c_proj_obj: brcddb.classes.project.ProjectObj
    :param c_obj: This is the object from compare.compare() that we are working on
    :type c_obj: dict
    :return sheet_index: Next sheet index
    :rtype sheet_index: int
    :return tbl_contents: Table of contents for the fabrics
    :rtype. tbl_contents: list
    """
    # Set up the table of contents and sheet headers
    content = [
        dict(font='hdr_1', align='wrap', disp='Project changes'),
        dict(),
        dict(font='hdr_2', align='wrap', disp='Fabrics Added:'),
    ]

    # Add fabric changes
    for obj in [d for d in c_obj['_fabric_objs'].values() if d['r'] == 'Added']:
        content.append(dict(font='std', align='wrap',
                            disp=brcddb_fabric.best_fab_name(c_proj_obj.r_fabric_obj(obj.get('c')), True)))
    content.extend([dict(), dict(font='hdr_2', align='wrap', disp='Fabrics Removed:')])
    for obj in [d for d in c_obj['_fabric_objs'].values() if d['r'] == 'Removed']:
        content.append(dict(font='std', align='wrap',
                            disp=brcddb_fabric.best_fab_name(b_proj_obj.r_fabric_obj(obj.get('b')), True)))

    # Add switch changes
    content.extend([dict(), dict(font='hdr_2', align='wrap', disp='Switches Added:')])
    for obj in [d for d in c_obj['_switch_objs'].values() if d['r'] == 'Added']:
        content.append(dict(font='std', align='wrap',
                            disp=brcddb_switch.best_switch_name(c_proj_obj.r_switch_obj(obj.get('c')),
                                                                wwn=True, did=True)))
    content.extend([dict(), dict(font='hdr_2', align='wrap', disp='Switches Removed:')])
    for obj in [d for d in c_obj['_switch_objs'].values() if d['r'] == 'Removed']:
        content.append(dict(font='std', align='wrap',
                            disp=brcddb_switch.best_switch_name(b_proj_obj.r_switch_obj(obj.get('b')),
                                                                wwn=True, did=True)))

    # Add chassis changes
    content.extend([dict(), dict(font='hdr_2', align='wrap', disp='Chassis Added:')])
    for obj in [d for d in c_obj['_chassis_objs'].values() if d['r'] == 'Added']:
        content.append(dict(font='std', align='wrap',
                            disp=brcddb_chassis.best_chassis_name(c_proj_obj.r_chassis_obj(obj.get('c')), True)))
    content.extend([dict(), dict(font='hdr_2', align='wrap', disp='Chassis Removed:')])
    for obj in [d for d in c_obj['_chassis_objs'].values() if d['r'] == 'Removed']:
        content.append(dict(font='std', align='wrap',
                            disp=brcddb_chassis.best_chassis_name(b_proj_obj.r_chassis_obj(obj.get('b')), True)))

    # Sheet name and title
    sname = 'Project_Changes_' + str(sheet_index)
    report_utils.title_page(wb, None, sname, sheet_index, 'Project Changes', content, 80)

    return sheet_index+1, [dict(s=sname, d='Project Changes')]


def _page(wb, sheet_index, b_proj_obj, c_proj_obj, c_obj, page):
    """Recursively iterates through a list of changes from compare.compare() for fabric. Create fabric pages as needed

    :param wb: Workbook object
    :type wb: dict
    :param sheet_index: Starting sheet index
    :type sheet_index: int
    :param b_proj_obj: Project object for base (project we are comparing against). Typically, the older project.
    :type b_proj_obj: brcddb.classes.project.ProjectObj
    :param c_proj_obj: Comparison project object. Typically, the newer project.
    :type c_proj_obj: brcddb.classes.project.ProjectObj
    :param c_obj: This is the object from compare.compare() that we are working on
    :type c_obj: dict
    :param page: Page type: _fabric_objs, _chassis_objs, or _switch_objs
    :type page: str
    :return sheet_index: Next sheet index
    :rtype sheet_index: int
    :return tbl_contents: Table of contents for the fabrics
    :rtype. tbl_contents: list
    """
    global _main_pages

    # Set up the table of contents and sheet headers
    tbl_contents = list()
    if not isinstance(c_obj, dict):
        return sheet_index, tbl_contents  # This happens when there are no changes
    for base_key, f_obj in c_obj.items():
        b_fab_obj, c_fab_obj = b_proj_obj.r_fabric_obj(base_key), c_proj_obj.r_fabric_obj(base_key)
        t_content = [dict(font='hdr_2', align='wrap', disp=('Key', 'Base Value', 'Compare Value', 'Change'))]
        obj_tbl = _action_table[page]

        # Add each individual item for the brcddb object to the sheet
        if b_fab_obj is not None and c_fab_obj is not None:  # The principal fabric switch may not have been polled
            for k, cntl_tbl in obj_tbl.items():
                obj = f_obj.get(k)
                if obj is not None:
                    # obj can be None if code was upgraded and a new KPI was introduced and captured. This logic skips
                    # reporting on anything new because we have no idea what the previous version would have been
                    t_content.append(dict())
                    t_content.append(dict(font='hdr_2', merge=4, align='wrap', disp=cntl_tbl.get('t')))
                    cntl_tbl.get('f')(obj, b_fab_obj, c_fab_obj, t_content)

        # Add each item added to the brcddb object (these are the items from the API)
        t_content.append(dict())
        t_content.append(dict(font='hdr_2', merge=4, align='wrap', disp='Added from RESTConf API'))
        for k1 in [key for key in f_obj.keys() if key not in obj_tbl]:
            _api_added_compares(f_obj, k1, list(), t_content)
        # Sheet name and title
        title, sname = _main_pages[page]['ts'](b_proj_obj, base_key)
        sname = sname.replace(' ', '_').replace(':', '').replace('-', '_')
        sname = sname[:28] + '_' + str(sheet_index) if len(sname) > 28 else sname + '_' + str(sheet_index)
        tbl_contents.append(dict(s=sname, d=title))

        report_utils.title_page(wb, None, sname, sheet_index, title, _main_pages[page]['sc'](t_content),
                                (42, 45, 45, 24))
        sheet_index += 1

    return sheet_index, tbl_contents


# After the fact, I realized I needed to sort the display output. The next 2 methods sort and filter the output
def _sort_switch(content):
    re, rl = list(), list()
    for obj in content:
        try:
            key = obj.get('disp')[0]
        except (TypeError, IndexError):
            key = ''
        if not key.startswith('brocade-maps/group/members'):
            if key.startswith('Port '):
                re.append(obj)
            else:
                rl.append(obj)

    rl.append(dict())
    rl.append(dict(merge=4, font='hdr_2', align='wrap', disp=('Ports',)))
    if len(re) == 0:
        rl.append(dict(merge=4, font='std', align='wrap', disp=('No changes',)))
    else:
        rl.extend(re)
    return rl


def _sort_null(content):
    return content


def _fabric_ts(o, k):
    """Returns the title of the sheet, which is also used in the report summary page, and the sheet name

    :param o: brcddb class object from which the key, k, is to be retrieved. So far, this has only been a project object
    :type o: brcddb.classes.project.ProjectObj
    :param k: The key for the object to retrieve from o
    :type k: key, str
    :return title: Sheet title
    :rtype title: str
    :return name: Sheet name
    :rtype name: str
    """
    obj = o.r_fabric_obj(k)
    return brcddb_fabric.best_fab_name(obj, True), \
        excel_util.valid_sheet_name.sub('_', brcddb_fabric.best_fab_name(obj, False))


def _chassis_ts(o, k):  # Similar to _fabric_ts()
    obj = o.r_chassis_obj(k)
    return brcddb_chassis.best_chassis_name(obj, True), \
        excel_util.valid_sheet_name.sub('_', brcddb_chassis.best_chassis_name(obj, False))


def _switch_ts(o, k):  # Similar to _fabric_ts()
    obj = o.r_switch_obj(k)  # valid_sheet_name.sub('_', bad_sheet_name)
    return brcddb_switch.best_switch_name(obj, True), \
        excel_util.valid_sheet_name.sub('_', brcddb_switch.best_switch_name(obj))


_main_pages = dict(  # Key is in _action_table. 's': sheet name. 't': sheet title. 'n': method to return object name
    _fabric_objs=dict(s='F_', t='Fabric Comparisons: ', n=_fabric_name, sc=_sort_null, ts=_fabric_ts),
    _switch_objs=dict(s='S_', t='Switch Comparisons: ', n=_switch_name, sc=_sort_switch, ts=_switch_ts),
    _chassis_objs=dict(s='C_', t='Chassis Comparisons: ', n=_chassis_name, sc=_sort_null, ts=_chassis_ts),
)


def _login_obj_name(obj, k, wwn):
    if obj is None or k is None or wwn is None:
        return wwn
    fab_obj = obj.r_fabric_obj(k)
    if fab_obj is None:
        return wwn
    alias_l = fab_obj.r_alias_for_wwn(wwn)
    return alias_l[0] + ' (' + wwn + ')' if len(alias_l) > 0 else wwn


def _project_scrub(c_obj):
    """Pulls out changes that are really overall project specific from fabric, chassis, and switch objects

    :param c_obj: Change object returned from brcddb.util.compare.compare()
    :type c_obj: dict
    :return: Compare object with '_project_obj'
    :rtype: dict
    """
    project_d = dict(_fabric_objs=dict(), _switch_objs=dict(), _chassis_objs=dict())
    rd = dict(_project_obj=project_d)
    for k0, d0 in c_obj.items():
        if k0 in (project_d.keys()):
            for k1, d1 in d0.items():
                if 'b' in d1 and 'c' in d1 and 'r' in d1:  # It's just an added or removed fabric, switch, or chassis
                    project_d[k0].update({k1: d1})
                else:
                    if k0 not in rd:
                        rd.update({k0: dict()})
                    rd[k0].update({k1: d1})
        else:
            rd.update({k0: d0})

    return rd


def _new_report(c, b_proj_obj, c_proj_obj, c_obj, r_name):
    """Generates an Excel comparison report

    :param c: Total number of changes. Typically, the number of changes returned from brcddb.util.compare.compare()
    :type c: int
    :param b_proj_obj: Project object for base (project we are comparing against). Typically, the older project.
    :type b_proj_obj: brcddb.classes.project.ProjectObj, None
    :param c_proj_obj: Comparison project object. Typically, the newer project.
    :type c_proj_obj: brcddb.classes.project.ProjectObj, None
    :param c_obj: Change object returned from brcddb.util.compare.compare()
    :type c_obj: dict
    :param r_name: Name of Excel workbook file
    :type r_name: str
    """
    global _main_pages

    # Set up the workbook
    sheet_index = 0
    wb = excel_util.new_report()

    # Set up the Project summary sheet with table of content
    title = b_proj_obj.r_obj_key() + ' Compared to ' + c_proj_obj.r_obj_key()
    tc_page = 'Project_Summary'
    t_content = [
        dict(font='std', align='wrap', disp=('Total changes', c)),
        dict(),
        dict(font='hdr_2', align='wrap', disp=('Key', 'Base Value', 'Compare Value', 'Change')),
    ]

    # Add any added changes to the project objects
    for k, obj in c_obj.items():
        if k not in _main_pages.keys() and k != '_project_obj':
            t_content.append(dict(font='std', align='wrap', disp=(k, obj.get('b'), obj.get('c'), obj.get('r'))))
    t_content.append(dict())

    # Add the project change sheet
    sheet_index, tbl_contents = _project_page(wb, sheet_index, b_proj_obj, c_proj_obj, c_obj.get('_project_obj'))
    d = tbl_contents[0]
    td = dict(font='link', merge=4, align='wrap', disp=d.get('d'))
    td.update(hyper='#' + d.get('s') + '!A1')
    t_content.append(td)

    # Add all the chassis, switch and fabric sheets
    for k, p_obj in _main_pages.items():
        t_content.append(dict())
        t_content.append(dict(font='hdr_2', merge=4, align='wrap', disp=p_obj.get('t')))
        sheet_index, tbl_contents = _page(wb, sheet_index, b_proj_obj, c_proj_obj, c_obj.get(k), k)
        for d in tbl_contents:
            td = dict(font='link', merge=4, align='wrap', disp=d.get('d'))
            if 's' in d:  # Is there a link to a page?
                td.update(hyper='#' + d.get('s') + '!A1')
                t_content.append(td)

    # Add the project summary with table of contents and save the report.
    report_utils.title_page(wb, None, tc_page, 0, title, t_content, (24, 42, 42, 12))
    excel_util.save_report(wb, r_name)


def pseudo_main(bf, cf, rf):
    """Basically the main(). Did it this way, so it can easily be used as a standalone module or called from another.

    :param bf: Base file
    :type bf: str
    :param cf: Compare file
    :type cf: str
    :param rf: Report file
    :type rf: str
    :return: Exit code. See exist codes in brcddb.brcddb_common
    :rtype: int
    """
    global _generic_table_add, _key_conv_tbl, _control_tables

    # Read the projects to compare and build the cross-references
    ml = list()
    input_file_d = dict(b=dict(file=bf, t='-b'), c=dict(file=cf, t='-c'))
    for d in input_file_d.values():
        try:
            d.update(obj=brcddb_project.read_from(d['file']))
            if d['obj'] is None:
                ml.append('Error reading ' + d['file'] + ', ' + d['t'] +
                          '. Check previous messages in the log for details.')
            else:
                brcddb_project.build_xref(d['obj'])
        except FileNotFoundError:
            ml.append('File ' + d['file'] + ' not found.')
        except FileExistsError:
            ml.append('A folder in the path ' + d['file'] + ' does not exist.')
        except PermissionError:
            ml.append('Permission error reading: ' + d['file'] + '.')
        except BaseException as e:
            ml.append('File ' + d['file'] + ' is not a valid JSON formatted file. Error messages is:')
            ml.append(str(type(e)) + ': ' + str(e))
    if len(ml) > 0:
        brcdapi_log.log(ml, echo=True)
        return brcddb_common.EXIT_STATUS_ERROR

    # Build out the key conversion tables. Used in _format_disp()
    for k, v in brcddb_rt.Port.port_display_tbl.items():
        if k[0] != '_':  # Make sure it's not a custom key
            _key_conv_tbl.update({'_port_objs/s/p/' + k: v.get('d')})
    for k, v in brcddb_rt.Login.login_display_tbl.items():
        if k[0] != '_':  # Make sure it's not a custom key
            _key_conv_tbl.update({k: v.get('d')})
    for table_obj in _generic_table_add:
        for k, v in table_obj.items():
            if k[0] != '_':  # Make sure it's not a custom key
                if isinstance(v, dict):
                    for k1, v1 in v.items():
                        _key_conv_tbl.update({k + '/' + k1: v1})
                else:
                    _key_conv_tbl.update({k: v})

    # Compare the two projects
    brcdapi_log.log('Please wait. The comparison may take several seconds', echo=True)
    c, compare_obj = brcddb_compare.compare(
        input_file_d['b']['obj'],
        input_file_d['c']['obj'],
        brcddb_control_tbl=_control_tables
    )

    brcdapi_log.log('Writing report: ' + rf, echo=True)
    try:
        _new_report(c, input_file_d['b']['obj'], input_file_d['c']['obj'], _project_scrub(compare_obj), rf)
    except (FileExistsError, FileNotFoundError):
        brcdapi_log.log('The path, folder, does not exist: ' + rf, echo=True)
    except PermissionError:
        brcdapi_log.log('Permission error writing ' + rf + '. This usually happens when the file is open.', echo=True)

    return brcddb_common.EXIT_STATUS_OK


def _get_input():
    """Parses the module load command line

    :return: Exit code. See exist codes in brcddb.brcddb_common
    :rtype: int
    """
    global __version__, _input_d

    # Get command line input
    args_d = gen_util.get_input('Create a MAPS report in Excel', _input_d)

    # Set up logging
    brcdapi_log.open_log(
        folder=args_d['log'],
        suppress=args_d['sup'],
        no_log=args_d['nl'],
        version_d=brcdapi_util.get_import_modules()
    )

    # Command line feedback
    ml = [os.path.basename(__file__) + ', ' + __version__,
          'Base file, -b:       ' + args_d['b'],
          'Compare file, -c:    ' + args_d['c'],
          'Report name, -r:     ' + args_d['r'],
          'Log, -log:           ' + str(args_d['log']),
          'No log, -nl:         ' + str(args_d['nl']),
          'Suppress, -sup:      ' + str(args_d['sup']),
          '',]
    brcdapi_log.log(ml, echo=True)

    return pseudo_main(brcdapi_file.full_file_name(args_d['b'], '.json'),
                       brcdapi_file.full_file_name(args_d['c'], '.json'),
                       brcdapi_file.full_file_name(args_d['r'], '.xlsx'))


##################################################################
#
#                    Main Entry Point
#
###################################################################
if _DOC_STRING:
    print('_DOC_STRING is True. No processing')
    exit(0)

if _STAND_ALONE:
    _ec = _get_input()
    brcdapi_log.close_log(['', 'Processing Complete. Exit code: ' + str(_ec)], echo=True)
    exit(_ec)
